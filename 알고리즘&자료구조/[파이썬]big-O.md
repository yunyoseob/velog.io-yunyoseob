**본 포스팅은 파이썬 알고리즘 인터뷰 책을 기반으로 만들어진 포스팅입니다.😊**

![](https://images.velog.io/images/yunyoseob/post/702df4d3-f09b-4344-8aff-9020d431cc1a/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B8%ED%84%B0%EB%B7%B0.jpg)

- [파이썬 알고리즘 인터뷰 : 박상길 지음, 정진호 일러스트](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9791189909178#N)

## big-O 표기법

컴퓨터 과학에서 빅오는 입력값이 커질 때 알고리즘의 실행 시간(시간 복잡도)과 함께 공간 요구사항(공간 복잡도)이 어떻게 증가하는지를 분류하는 데 사용되며, 알고리즘의 효율성을 분석하는 데에도 매우 유용하게 활용된다. 

> 빅오(O, big-O)란 입력값이 무한대로 향할 때, 함수의 상한을 설명하는 수학적 표기 방법이다.

## 시간복잡도

시간 복잡도는 어떤 알고리즘을 수행하는 데 걸리는 시간을 설명하는 계산 복잡도인데, 계산 복잡도를 표기하는 대표적인 방법이 빅오이다.

> 빅오 표기법의 종류

|종류|설명|
|---|---|
|**O(1)**|입력값이 아무리 커도 실행 시간은 일정함|
|**O(log n)**|실행 시간이 입력값에 영향을 받으나, 로그는 큰 입력값에도 크게 영향을 받지 않음|
|**O(n)**|알고리즘을 수행하는 데 걸리는 시간은 입력값에 비례함|
|**O(n log n)**|병합 정렬을 비롯한 대부분의 효율 좋은 정렬 알고리즘|
|**O(n^2)**|버블 정렬 같은 비효율적인 정렬 알고리즘이 이에 해당함|
|**O(n!)**|가장 느린 알고리즘으로, 가장 짧은 경로를 찾는 외판원 문제 풀이시 사용됨|

## 공간 복잡도

저장 공간에는 '고정 공간'과 '가변 공간'이 있습니다.

파이썬의 경우, 모든 것이 객체인데, 파이썬에서 변수를 할당하는 작업은 해당 객체에 대한 참조를 한다는 의미입니다.

> **파이썬 자료형의 불변 객체 여부**

|클래스|설명|불변 객체|
|---|---|---|
|bool|부울|O|
|int|정수|O|
|float|실수|O|
|list|리스트|X|
|tuple|리스트와 튜플의 차이는 불변 여부이며, 이외에는 거의 동일함(튜플은 불변)|O|
|str|문자|O|
|set|중복된 값을 갖지 않는 집합 자료형|X|
|dict|딕셔너리|X|


>  **참고: Space-Time-Trade-Off** 
실행 시간이 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 차지하는 알고리즘은 실행 시간이 느리다. 이러한 관계를 시간과 공간의 트레이드 오프 관계라고 한다.

![](https://images.velog.io/images/yunyoseob/post/7abaf118-2a14-455b-a9bf-b5799ed0c2ec/bigograph.png)


> **참고:빅오, 빅오메가, 빅세타**
빅오는 상한을 의미하며, 빅오메가는 하한을, 빅세타는 평균을 의미합니다.
빅오 표기법은 주어진(최선/최악/평균) 경우의 수행 시간의 상한을 나타냅니다.



## 분할 상환 분석
분할 상환 분석은 빅오와 함께 함수의 동작을 설명할 때 중요한 분석 방법 중 하나 입니다.
알고리즘을 분석할 때에 각각의 연산마다 최악의 경우를 따져본다는 것은 굉장히 힘든 일인데,
분할 상환 분석은 최악의 경우를 여러 번에 걸쳐 골고루 나눠주는 형태로 알고리즘의 시간 복잡도를 계산하여 이를 보완한 방법론입니다. 분할 상환 분석은 최악의 경우에도 각 연산의 평균 수행 성능을 보장합니다.

> [참고 : Robert Tarjan : Amortized Computational Complexity](https://www.cs.princeton.edu/courses/archive/spr09/cos423/Lectures/amortized-cc.pdf)

## 병렬화

최근 딥러닝의 인기와 함께 병렬화가 큰 주목을 받고 있으며, CPU에 비해 GPU는 많은 연산을 동시에 수행(병렬 연산)할 수 있으므로, 딥러닝에서 병렬 연산을 위해 중요하게 쓰입니다. 

이러한 측면에서 알고리즘 역시, 병렬 연산이 가능한지 유무가 근래에 알고리즘의 우수성을 평가하는 매우 중요한 척도 중 하나이기도 합니다.


> Python에서도 multiprocessing, Ray 등 병렬 처리를 지원하는 다양한 라이브러리가 있습니다.

## 파이썬 : 리스트와 딕셔너리의 주요 연산 시간 복잡도 사례

> 리스트의 주요 연산 시간 복잡도

|연산|시간 복잡도|
|---|---|
|**len(a)**|O(1)|
|**a[i]**|O(1)|
|**a[i:j]**|O(k)|
|**elem in a**|O(n)|
|**a.count(elem)**|O(n)|
|**a.index(elem)**|O(1)|
|**a.pop()**|O(1)|
|**a.pop(0)**|O(n)|
|**del a[i]**|O(n)|
|**a.sort()**|O(n log n)|
|**min(a), max(a)**|O(n)|
|**a.reverse()**|O(n)|

- 리스트의 경우, 탐색 시 값의 존재 유무를 확인하려면 정렬된 경우에는 이진 검색이 효율적이다. 그러나 매번 정렬이 필요하고 대개는 리스트가 정렬된 상태가 아니기 때문에, 리스트의 경우에는 모든 엘리먼트를 순차적으로 조회하는 형태로 구현되어 있다. 이 경우 최악의 경우 항상 O(n)이 소요된다.

> 딕셔너리의 주요 연산 시간 복잡도

|연산|시간 복잡도|
|---|---|
|**len(a)**|O(1)|
|**a[key]**|O(1)|
|**a[key]=value**|O(1)|
|**key in a**|O(1)|

-  딕셔너리는 대부분의 연산이 O(1)에 처리 가능한 우수한 자료형이다.
- 파이썬 3.7부터 내부적으로 인덱스를 이용해 입력 순서를 유지하도록 개선되었기 때문에 3.6 이하 버전의 경우, 딕셔너리 입력 순서가 유지되지 않는다. 
(collection 모듈에서 지원하는 collections.OrderedDict(), collections.defaultdict() 등을 활용 필요)

### 추가: 원시 타입 vs 객체

빅오 표기법에 대한 포스팅을 하면서 원시 타입과 객체에 대한 비교를 마지막으로 포스팅을 마무리 하고자 합니다.

> **원시 타입 : 원시 타입은 메모리에 정확하게 타입 크기만큼의 공간을 할당하고 그 공간을 오로지 값으로 채워넣는다. 매우 빠른 연산이 가능하다는 장점이 있다.**
- 대표적으로 C와 JAVA가 원시 타입을 제공한다.
- JAVA의 경우, 원시 타입에 대응되는 클래스 객체(Object)를 지원한다.

> **객체 : 파이썬은 모든 것이 객체이다. 이 중에서 크게 불변 객체와 가변 객체로 구분할 수 있다.**
- 공간 복잡도에 대한 설명에서 파이썬 자료형의 불변 객체 여부 표 참고

> **언어별 비교**

|언어|특징|
|--|--|
|**C**|원시 타입만을 지원|
|**JAVA**|원시 타입과 객체를 동시에 지원|
|**Python**|원시 타입을 지원하지 않음|

 파이썬의 경우, 애초에 편리한 기능 제공에 우선순위를 둔 언어인 만큼 원시 타입의 속도를 포기하는 대신 객체의 다양한 기능과 편의성을 택했다. 예시로, 다른 언어의 경우 동적 배열에 삽입 할 수 있는 자료형을 동일한 타입으로 제한하는 경우가 많은 데 비해, 파이썬은 자유롭게 삽입할 수 있다.
 
 ex ) 
 
```
a=[1,2,3,4,5]
a.append('안녕')
a.append(True)
a
[1,2,3,4,5,'안녕',True]
```
 
 
> **파이썬의 느린 속도 개선 모듈 : Numpy, Numba 등등**

파이썬이 비록 C나 JAVA에 비해 속도가 느려도, Numpy와 Numba 등 모듈 사용을 통해 이를 보완하고 극복할 수 있는 방법이 있다. Numpy의 경우, C로 만든 모듈이며 내부적으로 리스트를 C의 원시 타입으로 처리한다. Numba의 경우, Python 및 Numpy 코드의 하위 집합을 빠른 기계 코드로 변환하는 오픈 소스 JIT 컴파일러입니다. 파이썬의 컴파일 과정에서 JAVA나 C에 비해 느린 속도를 개선할 수 있는 Library입니다. 


**이상으로 알고리즘&자료구조 공부방 첫 번째 포스트를 마치도록 하겠습니다. 👍**
